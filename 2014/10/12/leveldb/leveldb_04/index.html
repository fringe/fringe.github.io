<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>leveldb源码剖析（004）-coding | Wu attar</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="1//coding.h 	相关编码问题
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949">
<meta property="og:type" content="article">
<meta property="og:title" content="leveldb源码剖析（004）-coding">
<meta property="og:url" content="http://yoursite.com/2014/10/12/leveldb/leveldb_04/index.html">
<meta property="og:site_name" content="Wu attar">
<meta property="og:description" content="1//coding.h 	相关编码问题
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="leveldb源码剖析（004）-coding">
<meta name="twitter:description" content="1//coding.h 	相关编码问题
123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949">
  
    <link rel="alternative" href="/atom.xml" title="Wu attar" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wu attar</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Wu attar</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="q" value="site:http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-leveldb/leveldb_04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/10/12/leveldb/leveldb_04/" class="article-date">
  <time datetime="2014-10-12T04:46:15.000Z" itemprop="datePublished">2014-10-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/leveldb源码剖析/">leveldb源码剖析</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      leveldb源码剖析（004）-coding
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//coding.h 	相关编码问题</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Endian-neutral encoding:</span></span><br><span class="line"><span class="comment">// * Fixed-length numbers are encoded with least-significant byte first</span></span><br><span class="line"><span class="comment">// * In addition we support variable length "varint" encoding</span></span><br><span class="line"><span class="comment">// * Strings are encoded prefixed by their length in varint format</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#ifndef STORAGE_LEVELDB_UTIL_CODING_H_</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> STORAGE_LEVELDB_UTIL_CODING_H_</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;stdint.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string.h&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> &lt;string&gt;</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "leveldb/slice.h"</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "port/port.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard Put... routines append to a string</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PutFixed32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PutFixed64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, uint64_t value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PutVarint64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, uint64_t value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Standard Get... routines parse a value from the beginning of a Slice</span></span><br><span class="line"><span class="comment">// and advance the slice past the parsed value.</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, uint64_t* value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointer-based variants of GetVarint...  These either store a value</span></span><br><span class="line"><span class="comment">// in *v and return a pointer just past the parsed value, or return</span></span><br><span class="line"><span class="comment">// NULL on error.  These routines only look at bytes in the range</span></span><br><span class="line"><span class="comment">// [p..limit-1]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* GetVarint32Ptr(<span class="keyword">const</span> <span class="keyword">char</span>* p,<span class="keyword">const</span> <span class="keyword">char</span>* limit, <span class="keyword">uint32_t</span>* v);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* GetVarint64Ptr(<span class="keyword">const</span> <span class="keyword">char</span>* p,<span class="keyword">const</span> <span class="keyword">char</span>* limit, uint64_t* v);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns the length of the varint32 or varint64 encoding of "v"</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">VarintLength</span><span class="params">(uint64_t v)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* dst, uint64_t value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lower-level versions of Put... that write directly into a character buffer</span></span><br><span class="line"><span class="comment">// and return a pointer just past the last byte written.</span></span><br><span class="line"><span class="comment">// REQUIRES: dst has enough space for the value being written</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>* EncodeVarint32(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> value);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>* EncodeVarint64(<span class="keyword">char</span>* dst, uint64_t value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Lower-level versions of Get... that read directly from a character buffer</span></span><br><span class="line"><span class="comment">// without any bounds checking.</span></span><br><span class="line"><span class="comment">//根据平台对大小端的数据进行解码（32位）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">uint32_t</span> <span class="title">DecodeFixed32</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="comment">// Load the raw bytes</span></span><br><span class="line">    <span class="keyword">uint32_t</span> result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, ptr, <span class="keyword">sizeof</span>(result));  <span class="comment">// gcc optimizes this to a plain load</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">0</span>])))</span><br><span class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">1</span>])) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">2</span>])) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">        | (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(ptr[<span class="number">3</span>])) &lt;&lt; <span class="number">24</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据平台对大小端的数据进行解码（64位）</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> uint64_t <span class="title">DecodeFixed64</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ptr)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="comment">// Load the raw bytes</span></span><br><span class="line">    uint64_t result;</span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;result, ptr, <span class="keyword">sizeof</span>(result));  <span class="comment">// gcc optimizes this to a plain load</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    uint64_t lo = DecodeFixed32(ptr);</span><br><span class="line">    uint64_t hi = DecodeFixed32(ptr + <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> (hi &lt;&lt; <span class="number">32</span>) | lo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Internal routine for use by fallback path of GetVarint32Ptr</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">char</span>* GetVarint32PtrFallback(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span><br><span class="line">                                          <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span><br><span class="line">                                          <span class="keyword">uint32_t</span>* value);</span><br><span class="line"><span class="comment">//将p中存放的变长编码数据取出存放到value中，并返回指向下一变长编码的首地址</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* GetVarint32Ptr(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span><br><span class="line">                                  <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span><br><span class="line">                                  <span class="keyword">uint32_t</span>* value) &#123;</span><br><span class="line">  <span class="keyword">if</span> (p &lt; limit) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> result = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    <span class="keyword">if</span> ((result &amp; <span class="number">128</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> p + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> GetVarint32PtrFallback(p, limit, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span>  <span class="comment">// STORAGE_LEVELDB_UTIL_CODING_H_</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//coding.cc	相关编码</span></span><br><span class="line"><span class="comment">// Copyright (c) 2011 The LevelDB Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style license that can be</span></span><br><span class="line"><span class="comment">// found in the LICENSE file. See the AUTHORS file for names of contributors.</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> "util/coding.h"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> leveldb &#123;</span><br><span class="line"><span class="comment">//根据平台的大端还是小端存储，对数据进行统一小端编码存储到字符串中中（32位）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodeFixed32</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, &amp;value, <span class="keyword">sizeof</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buf[<span class="number">0</span>] = value &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">3</span>] = (value &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据平台的大端还是小端存储，对数据进行统一小端编码存储到buf中（64位）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EncodeFixed64</span><span class="params">(<span class="keyword">char</span>* buf, uint64_t value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (port::kLittleEndian) &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf, &amp;value, <span class="keyword">sizeof</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buf[<span class="number">0</span>] = value &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">1</span>] = (value &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">2</span>] = (value &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">3</span>] = (value &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">4</span>] = (value &gt;&gt; <span class="number">32</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">5</span>] = (value &gt;&gt; <span class="number">40</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">6</span>] = (value &gt;&gt; <span class="number">48</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">    buf[<span class="number">7</span>] = (value &gt;&gt; <span class="number">56</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将数据进行小端编码后，追加到dst后（32）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutFixed32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(value)];</span><br><span class="line">  EncodeFixed32(buf, value);</span><br><span class="line">  dst-&gt;append(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数据进行小端编码后，追加到dst后（64）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutFixed64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, uint64_t value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(value)];</span><br><span class="line">  EncodeFixed64(buf, value);</span><br><span class="line">  dst-&gt;append(buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变长编码，将一个int类型使用变长编码的方式存储到dst中</span></span><br><span class="line"><span class="comment">//每个字节的最高位有特殊的含义，最高位为1，则后续也是该数字的一部分</span></span><br><span class="line"><span class="comment">//否则结束。剩下的7bit则表示数据，最多表示128个，而两个字节，则最多表示2^14</span></span><br><span class="line"><span class="keyword">char</span>* EncodeVarint32(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v) &#123;</span><br><span class="line">  <span class="comment">// Operate on characters as unsigned</span></span><br><span class="line"> <span class="comment">//将char* 类型强制转换成unsigned，reinterpret_cast函数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;	<span class="comment">//128</span></span><br><span class="line">    *(ptr++) = v;</span><br><span class="line">  &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(v &lt; (1&lt;&lt;14)</span>) </span>&#123;	<span class="comment">//2^14</span></span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;</span><br><span class="line">  &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(v &lt; (1&lt;&lt;21)</span>) </span>&#123;	<span class="comment">//2^21</span></span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</span><br><span class="line">  &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(v &lt; (1&lt;&lt;28)</span>) </span>&#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *(ptr++) = v | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</span><br><span class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</span><br><span class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将变长编码追加到dst中（32位）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</span><br><span class="line">  dst-&gt;append(buf, ptr - buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//变长编码，将一个int类型使用变长编码的方式存储到dst中（64位）</span></span><br><span class="line"><span class="keyword">char</span>* EncodeVarint64(<span class="keyword">char</span>* dst, uint64_t v) &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= B) &#123;</span><br><span class="line">    *(ptr++) = (v &amp; (B-<span class="number">1</span>)) | B;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *(ptr++) = <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(v);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint64</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, uint64_t v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">  <span class="keyword">char</span>* ptr = EncodeVarint64(buf, v);</span><br><span class="line">  dst-&gt;append(buf, ptr - buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将Slice数据和数据长度的变长编码追加到dst中，数据格式： size + data的变长编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutLengthPrefixedSlice</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  PutVarint32(dst, value.size());</span><br><span class="line">  dst-&gt;append(value.data(), value.size());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回待编码数据的变长编码字节数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">VarintLength</span><span class="params">(uint64_t v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (v &gt;= <span class="number">128</span>) &#123;</span><br><span class="line">    v &gt;&gt;= <span class="number">7</span>;</span><br><span class="line">    len++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//辅助回调函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GetVarint32PtrFallback(<span class="keyword">const</span> <span class="keyword">char</span>* p,</span><br><span class="line">                                   <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span><br><span class="line">                                   <span class="keyword">uint32_t</span>* value) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">28</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解码Slice中的变长编码数据（32位），Slice数据存放格式【变长编码+未知数据】</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint32</span><span class="params">(Slice* input, <span class="keyword">uint32_t</span>* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = input-&gt;data();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = p + input-&gt;size();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* q = GetVarint32Ptr(p, limit, value);</span><br><span class="line">  <span class="keyword">if</span> (q == NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *input = Slice(q, limit - q);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GetVarint64Ptr(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit, uint64_t* value) &#123;</span><br><span class="line">  uint64_t result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</span><br><span class="line">    uint64_t byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</span><br><span class="line">    p++;</span><br><span class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// More bytes are present</span></span><br><span class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result |= (byte &lt;&lt; shift);</span><br><span class="line">      *value = result;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//解码Slice中的变长编码数据（64位）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetVarint64</span><span class="params">(Slice* input, uint64_t* value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = input-&gt;data();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = p + input-&gt;size();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* q = GetVarint64Ptr(p, limit, value);</span><br><span class="line">  <span class="keyword">if</span> (q == NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    *input = Slice(q, limit - q);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串p中存放的【长度+数据】格式的变长编码数据取出存放到Slice中，并返回下一变长编码的首地址</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* GetLengthPrefixedSlice(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span><br><span class="line">                                   Slice* result) &#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  p = GetVarint32Ptr(p, limit, &amp;len);</span><br><span class="line">  <span class="keyword">if</span> (p == NULL) <span class="keyword">return</span> NULL;</span><br><span class="line">  <span class="keyword">if</span> (p + len &gt; limit) <span class="keyword">return</span> NULL;</span><br><span class="line">  *result = Slice(p, len);			<span class="comment">//使用的是赋值构造函数</span></span><br><span class="line">  <span class="keyword">return</span> p + len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将input中的data中的【数据长度(变长编码)+数据】转换成一个真正的Slice</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetLengthPrefixedSlice</span><span class="params">(Slice* input, Slice* result)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> len;</span><br><span class="line">  <span class="keyword">if</span> (GetVarint32(input, &amp;len) &amp;&amp;</span><br><span class="line">      input-&gt;size() &gt;= len) &#123;</span><br><span class="line">    *result = Slice(input-&gt;data(), len);</span><br><span class="line">    input-&gt;remove_prefix(len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace leveldb</span></span><br></pre></td></tr></table></figure>
<p><strong>学习知识点</strong><br>1.reinterpret_cast: 将一个类型转换成毫不相干的类型，对其进行操作之后，然后再转换回来；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/10/12/leveldb/leveldb_04/" data-id="cia0k32tb000i6bjxy9wukxgv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2014/10/12/leveldb/leveldb05/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          leveldb源码剖析（005）-arena
        
      </div>
    </a>
  
  
    <a href="/2014/10/11/leveldb/leveldb_03/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">leveldb源码剖析（003）-hash</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Common-Tools/">Common Tools</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/leveldb源码剖析/">leveldb源码剖析</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/常用工具/">常用工具</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/设计模式/">设计模式</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/高级Bash编程/">高级Bash编程</a><span class="category-list-count">13</span></li></ul>
    </div>
  </div>

  
    
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">十一月 2014</a><span class="archive-list-count">22</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">十月 2014</a><span class="archive-list-count">7</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2014/12/16/tools/irc/">IRC</a>
          </li>
        
          <li>
            <a href="/2014/12/16/tools/git/">GIT</a>
          </li>
        
          <li>
            <a href="/2014/12/16/tools/gdb/">GDB</a>
          </li>
        
          <li>
            <a href="/2014/12/16/tools/vim/">VIM</a>
          </li>
        
          <li>
            <a href="/2014/12/16/tools/mysql/">MYSQL</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 Michael Geller<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>